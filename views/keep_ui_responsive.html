<!--
Copyright 2018

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

Author: Ewa Gasperowicz (@devnook)
-->
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Offscreen Canvas</title>
  <link rel="stylesheet" href="/css/style.css" />
</head>

<body>
  <header class="hide-in-iframe">
    <h1>
      OffscreenCanvas
    </h1>
    <div class="desc">
      The OffscreenCanvas allows to create a canvas that can be rendered off screen. It
      can also be used in web workers.
    </div>
    <nav>
      <a href="index.html">Avoid jank</a>
      <a href="keep-ui-responsive.html" class="selected">Keep UI responsive</a>
      <a href="gain-cpu-time.html">Gain CPU time</a>
      <a href="use-with-lib.html">Use with a library</a>
    </nav>
  </header>
  <main class="supported">
    <section class="support">Your browser does not support OffscreenCanvas.</section>
    <section>
      <p class="hide-in-iframe">
        If an app has long running rendering tasks (e.g. ray tracing in WebGL), running those
        tasks in a worker allows the web app’s UI to remain responsive while the rendering
        task runs continuously in the background.
      </p>
      <p class="desc">
        The animation below is running a heavy task while changing the color theme.
        If you click on the button at such moment, the interaction is blocked
        for a short while causing bad user experience.
      </p>
      <p>
        <input type="checkbox" id="play" class="cbx hidden"/>
        <label for="play" id="play-label" class="lbl">Runs on main thread</label>
      </p>
      <p>
        <button id="interactive">Interact! Counter: <span id="log">0</span></button>
      </p>

      <div class="display">
        <div>
          <h1>Canvas on main thread</h1>
          <p>Interaction is blocked when a theme is loading</p>
          <canvas id="canvas-window" width="400" height="400"></canvas>
        </div>
        <div>
          <h1>Canvas on worker thread</h1>
          <p>Interaction works even if a theme is loading</p>
          <canvas id="canvas-worker" width="400" height="400"></canvas>
        </div>
      </div>
    </section>
  </main>

  <!-- Traer las clases que llevan a cabo la animación -->
  <script src="scripts/animation.js"></script>

  <!-- Script del hilo Worker -->
  <script type="script/worker" id="workerCode">
  
    // Comprobar si el código del Worker se ejecuta en el main también.
	// Eso ocurre cuando la etiqueta <script> no tiene definido el tipo. En este caso, no.
	console.log('> Ejecución del código Worker.');
  
    // Con su creación el hilo se prepara para crear un objeto animador.
	// Aún no tiene código que defina el objeto animador, espera a que main le diga dónde encontrarlo.
    let animationWorker = null;
	
	// Queda a la espera de recibir un mensaje de inicio/detención.
	// En un principio, hay que abrir la parte del mensaje que tiene el contexto y las definiciones.
    self.onmessage = function(e) {
      switch (e.data.msg) {
	  
	    // Crear el objeto animador si no existía aún. Offscreen funciona como cualquier canvas.
        case 'start':
          if (!animationWorker) {
            importScripts(e.data.origin + '/scripts/animation.js');
            animationWorker = new ThemedAnimation(e.data.canvas.getContext('2d'));
			console.log('> El worker ya tiene un objeto animador.');
          }
          animationWorker.start();
          break;
		
		// Detener el animador al recibir el mensaje adecuado del main.
		// El Worker nunca le pasa mensajes al main porque el contexto del segundo canvas ya es suyo.
        case 'stop':
          if (!animationWorker) {
            return;
          }
          animationWorker.stop();
          break;
      }
    };
  </script>

  <!-- script del hilo main -->
  <script>
  
	  // Comprobar el punto de ejecución de este script
	  console.log('> Ejecución del segundo script.');
	
	  // Se corre una instancia de Worker (hilo) con el código de arriba, contenido en una dirección URL
      const workerCode = document.querySelector('#workerCode').textContent;
      const blob = new Blob([workerCode], { type: 'text/javascript' });
      const url = URL.createObjectURL(blob);
      const worker = new Worker(url);

      // Se inicializa un objeto animador, a nivel main, con las definiciones traidas del primer script
	  // El Worker no ha comenzado a animar, está esperando definiciones y contexto.
      const animationWindow = new ThemedAnimation(document.querySelector('#canvas-window').getContext('2d'));
      
	  // El segundo canvas puede transferir al Worker el control de su contexto.
	  // para eso, se lo tiene que enviar a través de un mensaje con un objeto Offscreen conteniéndolo.
	  const offscreen = document.querySelector('#canvas-worker').transferControlToOffscreen();
	  
	  // Esta bandera indica que el Worker ya tiene un objeto animador.
      let workerStarted = false;

      // Elemento que ilustra la interacción fluida con main al delegar la animación al Worker:
	  // Aumentar en 1 un contador por clic.
      document.querySelector('#interactive').addEventListener('click', () => {
        const logBox = document.querySelector('#log');
        const value = parseInt(logBox.innerText, 10) + 1;
        logBox.innerText = value;
      });

	  // Ejecutar el cambio de hilo cuando el botón sea movido por el usuario.
	  // Como el botón está en main, no va a poder cambiar fluidamente si tiene que hacer fibonaccis.
      const playBtn = document.querySelector('#play');
      const playLabel = document.querySelector('#play-label');
      playBtn.addEventListener('change', (e) => {
        const inWorker = e.target.checked;
        playLabel.innerHTML = inWorker ? 'Runs in worker' : 'Runs on main thread';
        playAnimation(inWorker);
      });

	  // Función de cambio de hilo: recibe como parámetro si el hilo destino es el Worker.
      function playAnimation(inWorker) {
	    
		// Cambio a Worker: detiene el animador del main y comprueba si la instancia de Worker tiene uno.
        if (inWorker) {
          animationWindow.stop();
		  
		  // Si la instancia ya tiene objeto animador, solo le envía un mensaje de inicio.
          if (workerStarted) {
            worker.postMessage({ msg: 'start' });
			
		  // Si el Worker está a la espera de definiciones, se le indica el origen de estas.
		  // También se envía el contexto del segundo Canvas con el objeto TRANSFERIBLE Offscreen.
          } else {
		  
		    // arreglar la URL obtenida directamente de la propiedad location.
            const urlParts = location.href.split('/');
            if (urlParts[urlParts.length - 1].indexOf('.') !== -1) {
              urlParts.pop();
            }
			const fixed_url = urlParts.join('/');
			
			// Pasar el mensaje de inicio con la info. que faltaba y registrarlo en la bandera.
            worker.postMessage({ msg: 'start', origin: fixed_url, canvas: offscreen }, [offscreen]);
            console.log('> El lugar donde encontrar las definiciones: ' + fixed_url);
			workerStarted = true;
          }
		
		// Cambio a Main: Correr animador del main y mensajear al Worker para detener su animador.
        } else {
          worker.postMessage({ msg: 'stop' });
          animationWindow.start();
        }
      }
	  
	  // Iniciar el programa con el animador del main funcionando.
      animationWindow.start();
  </script>
</body>

</html>
